{"ast":null,"code":"import _regeneratorRuntime from \"/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nvar _jsxFileName = \"/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/packages/frontend/src/Login/Login.tsx\";\nimport './Login.css';\nimport React from 'react';\nimport Web3 from 'web3';\nlet web3 = undefined; // Will hold the web3 instance\n\nexport class Login extends React.Component {\n  constructor(...args) {\n    var _this;\n\n    super(...args);\n    _this = this;\n    this.state = {\n      loading: false // Loading button state\n\n    };\n\n    this.handleAuthenticate = ({\n      publicAddress,\n      signature\n    }) => fetch(\"\".concat(process.env.REACT_APP_BACKEND_URL, \"/auth\"), {\n      body: JSON.stringify({\n        publicAddress,\n        signature\n      }),\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      method: 'POST'\n    }).then(response => response.json());\n\n    this.handleClick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var onLoggedIn, coinbase, publicAddress;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            onLoggedIn = _this.props.onLoggedIn; // Check if MetaMask is installed\n\n            if (window.ethereum) {\n              _context.next = 4;\n              break;\n            }\n\n            window.alert('Please install MetaMask first.');\n            return _context.abrupt(\"return\");\n\n          case 4:\n            if (web3) {\n              _context.next = 15;\n              break;\n            }\n\n            _context.prev = 5;\n            _context.next = 8;\n            return window.ethereum.enable();\n\n          case 8:\n            // We don't know window.web3 version, so we use our own instance of Web3\n            // with the injected provider given by MetaMask\n            web3 = new Web3(window.ethereum);\n            _context.next = 15;\n            break;\n\n          case 11:\n            _context.prev = 11;\n            _context.t0 = _context[\"catch\"](5);\n            window.alert('You need to allow MetaMask.');\n            return _context.abrupt(\"return\");\n\n          case 15:\n            _context.next = 17;\n            return web3.eth.getCoinbase();\n\n          case 17:\n            coinbase = _context.sent;\n\n            if (coinbase) {\n              _context.next = 21;\n              break;\n            }\n\n            window.alert('Please activate MetaMask first.');\n            return _context.abrupt(\"return\");\n\n          case 21:\n            publicAddress = coinbase.toLowerCase();\n\n            _this.setState({\n              loading: true\n            }); // Look if user with current publicAddress is already present on backend\n\n\n            fetch(\"\".concat(process.env.REACT_APP_BACKEND_URL, \"/users?publicAddress=\").concat(publicAddress)).then(response => response.json()) // If yes, retrieve it. If no, create it.\n            .then(users => users.length ? users[0] : _this.handleSignup(publicAddress)) // Popup MetaMask confirmation modal to sign message\n            .then(_this.handleSignMessage) // Send signature to backend on the /auth route\n            .then(_this.handleAuthenticate) // Pass accessToken back to parent component (to save it in localStorage)\n            .then(onLoggedIn).catch(err => {\n              window.alert(err);\n\n              _this.setState({\n                loading: false\n              });\n            });\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[5, 11]]);\n    }));\n\n    this.handleSignMessage = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2({\n        publicAddress,\n        nonce\n      }) {\n        var signature;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return web3.eth.personal.sign(\"I am signing my one-time nonce: \".concat(nonce), publicAddress, '' // MetaMask will ignore the password argument here\n              );\n\n            case 3:\n              signature = _context2.sent;\n              return _context2.abrupt(\"return\", {\n                publicAddress,\n                signature\n              });\n\n            case 7:\n              _context2.prev = 7;\n              _context2.t0 = _context2[\"catch\"](0);\n              throw new Error('You need to sign the message to be able to log in.');\n\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[0, 7]]);\n      }));\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this.handleSignup = publicAddress => {\n      return fetch(\"\".concat(process.env.REACT_APP_BACKEND_URL, \"/users\"), {\n        body: JSON.stringify({\n          publicAddress\n        }),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        method: 'POST'\n      }).then(response => response.json());\n    };\n  }\n\n  render() {\n    const loading = this.state.loading;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"button\", {\n      className: \"Login-button Login-mm\",\n      onClick: this.handleClick,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 121,\n        columnNumber: 9\n      }\n    }, loading ? 'Loading...' : 'Login with MetaMask'));\n  }\n\n}","map":{"version":3,"sources":["/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/packages/frontend/src/Login/Login.tsx"],"names":["React","Web3","web3","undefined","Login","Component","state","loading","handleAuthenticate","publicAddress","signature","fetch","process","env","REACT_APP_BACKEND_URL","body","JSON","stringify","headers","method","then","response","json","handleClick","onLoggedIn","props","window","ethereum","alert","enable","eth","getCoinbase","coinbase","toLowerCase","setState","users","length","handleSignup","handleSignMessage","catch","err","nonce","personal","sign","Error","render"],"mappings":"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","sourcesContent":["import './Login.css';\n\nimport React from 'react';\nimport Web3 from 'web3';\n\nimport { Auth } from '../types';\n\ninterface Props {\n  onLoggedIn: (auth: Auth) => void;\n}\n\nlet web3: Web3 | undefined = undefined; // Will hold the web3 instance\n\nexport class Login extends React.Component<Props> {\n  state = {\n    loading: false, // Loading button state\n  };\n\n  handleAuthenticate = ({\n    publicAddress,\n    signature,\n  }: {\n    publicAddress: string;\n    signature: string;\n  }) =>\n    fetch(`${process.env.REACT_APP_BACKEND_URL}/auth`, {\n      body: JSON.stringify({ publicAddress, signature }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    }).then((response) => response.json());\n\n  handleClick = async () => {\n    const { onLoggedIn } = this.props;\n\n    // Check if MetaMask is installed\n    if (!(window as any).ethereum) {\n      window.alert('Please install MetaMask first.');\n      return;\n    }\n\n    if (!web3) {\n      try {\n        // Request account access if needed\n        await (window as any).ethereum.enable();\n\n        // We don't know window.web3 version, so we use our own instance of Web3\n        // with the injected provider given by MetaMask\n        web3 = new Web3((window as any).ethereum);\n      } catch (error) {\n        window.alert('You need to allow MetaMask.');\n        return;\n      }\n    }\n\n    const coinbase = await web3.eth.getCoinbase();\n    if (!coinbase) {\n      window.alert('Please activate MetaMask first.');\n      return;\n    }\n\n    const publicAddress = coinbase.toLowerCase();\n    this.setState({ loading: true });\n\n    // Look if user with current publicAddress is already present on backend\n    fetch(\n      `${process.env.REACT_APP_BACKEND_URL}/users?publicAddress=${publicAddress}`\n    )\n      .then((response) => response.json())\n      // If yes, retrieve it. If no, create it.\n      .then((users) =>\n        users.length ? users[0] : this.handleSignup(publicAddress)\n      )\n      // Popup MetaMask confirmation modal to sign message\n      .then(this.handleSignMessage)\n      // Send signature to backend on the /auth route\n      .then(this.handleAuthenticate)\n      // Pass accessToken back to parent component (to save it in localStorage)\n      .then(onLoggedIn)\n      .catch((err) => {\n        window.alert(err);\n        this.setState({ loading: false });\n      });\n  };\n\n  handleSignMessage = async ({\n    publicAddress,\n    nonce,\n  }: {\n    publicAddress: string;\n    nonce: string;\n  }) => {\n    try {\n      const signature = await web3!.eth.personal.sign(\n        `I am signing my one-time nonce: ${nonce}`,\n        publicAddress,\n        '' // MetaMask will ignore the password argument here\n      );\n\n      return { publicAddress, signature };\n    } catch (err) {\n      throw new Error('You need to sign the message to be able to log in.');\n    }\n  };\n\n  handleSignup = (publicAddress: string) => {\n    return fetch(`${process.env.REACT_APP_BACKEND_URL}/users`, {\n      body: JSON.stringify({ publicAddress }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    }).then((response) => response.json());\n  };\n\n  render() {\n    const { loading } = this.state;\n    return (\n      <div>\n        <button className=\"Login-button Login-mm\" onClick={this.handleClick}>\n          {loading ? 'Loading...' : 'Login with MetaMask'}\n        </button>\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}