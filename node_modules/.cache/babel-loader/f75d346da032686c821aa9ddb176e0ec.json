{"ast":null,"code":"\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version); ///////////////////////////////\n\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n\n  return getAddress(value);\n}\n\nfunction handleNumber(value) {\n  if (value === \"0x\") {\n    return Zero;\n  }\n\n  return BigNumber.from(value);\n}\n\nconst transactionFields = [{\n  name: \"nonce\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasPrice\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasLimit\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"to\",\n  length: 20\n}, {\n  name: \"value\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"data\"\n}];\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true\n};\nexport function computeAddress(key) {\n  const publicKey = computePublicKey(key);\n  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n  return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nexport function serialize(transaction, signature) {\n  checkProperties(transaction, allowedTransactionKeys);\n  const raw = [];\n  transactionFields.forEach(function (fieldInfo) {\n    let value = transaction[fieldInfo.name] || [];\n    const options = {};\n\n    if (fieldInfo.numeric) {\n      options.hexPad = \"left\";\n    }\n\n    value = arrayify(hexlify(value, options)); // Fixed-width field\n\n    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n      logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n    } // Variable-width (with a maximum)\n\n\n    if (fieldInfo.maxLength) {\n      value = stripZeros(value);\n\n      if (value.length > fieldInfo.maxLength) {\n        logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n      }\n    }\n\n    raw.push(hexlify(value));\n  });\n  let chainId = 0;\n\n  if (transaction.chainId != null) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = transaction.chainId;\n\n    if (typeof chainId !== \"number\") {\n      logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n    }\n  } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n    // No chainId provided, but the signature is signing with EIP-155; derive chainId\n    chainId = Math.floor((signature.v - 35) / 2);\n  } // We have an EIP-155 transaction (chainId was specified and non-zero)\n\n\n  if (chainId !== 0) {\n    raw.push(hexlify(chainId));\n    raw.push(\"0x\");\n    raw.push(\"0x\");\n  } // Requesting an unsigned transation\n\n\n  if (!signature) {\n    return RLP.encode(raw);\n  } // The splitSignature will ensure the transaction has a recoveryParam in the\n  // case that the signTransaction function only adds a v.\n\n\n  const sig = splitSignature(signature); // We pushed a chainId and null r, s on for hashing only; remove those\n\n  let v = 27 + sig.recoveryParam;\n\n  if (chainId !== 0) {\n    raw.pop();\n    raw.pop();\n    raw.pop();\n    v += chainId * 2 + 8; // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n\n    if (sig.v > 28 && sig.v !== v) {\n      logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n  } else if (sig.v !== v) {\n    logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n  }\n\n  raw.push(hexlify(v));\n  raw.push(stripZeros(arrayify(sig.r)));\n  raw.push(stripZeros(arrayify(sig.s)));\n  return RLP.encode(raw);\n}\nexport function parse(rawTransaction) {\n  const transaction = RLP.decode(rawTransaction);\n\n  if (transaction.length !== 9 && transaction.length !== 6) {\n    logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n  }\n\n  const tx = {\n    nonce: handleNumber(transaction[0]).toNumber(),\n    gasPrice: handleNumber(transaction[1]),\n    gasLimit: handleNumber(transaction[2]),\n    to: handleAddress(transaction[3]),\n    value: handleNumber(transaction[4]),\n    data: transaction[5],\n    chainId: 0\n  }; // Legacy unsigned transaction\n\n  if (transaction.length === 6) {\n    return tx;\n  }\n\n  try {\n    tx.v = BigNumber.from(transaction[6]).toNumber();\n  } catch (error) {\n    console.log(error);\n    return tx;\n  }\n\n  tx.r = hexZeroPad(transaction[7], 32);\n  tx.s = hexZeroPad(transaction[8], 32);\n\n  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n    // EIP-155 unsigned transaction\n    tx.chainId = tx.v;\n    tx.v = 0;\n  } else {\n    // Signed Tranasaction\n    tx.chainId = Math.floor((tx.v - 35) / 2);\n\n    if (tx.chainId < 0) {\n      tx.chainId = 0;\n    }\n\n    let recoveryParam = tx.v - 27;\n    const raw = transaction.slice(0, 6);\n\n    if (tx.chainId !== 0) {\n      raw.push(hexlify(tx.chainId));\n      raw.push(\"0x\");\n      raw.push(\"0x\");\n      recoveryParam -= tx.chainId * 2 + 8;\n    }\n\n    const digest = keccak256(RLP.encode(raw));\n\n    try {\n      tx.from = recoverAddress(digest, {\n        r: hexlify(tx.r),\n        s: hexlify(tx.s),\n        recoveryParam: recoveryParam\n      });\n    } catch (error) {\n      console.log(error);\n    }\n\n    tx.hash = keccak256(rawTransaction);\n  }\n\n  return tx;\n}","map":{"version":3,"sources":["/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/@ethersproject/transactions/lib.esm/index.js"],"names":["getAddress","BigNumber","arrayify","hexDataSlice","hexlify","hexZeroPad","isBytesLike","splitSignature","stripZeros","Zero","keccak256","checkProperties","RLP","computePublicKey","recoverPublicKey","Logger","version","logger","handleAddress","value","handleNumber","from","transactionFields","name","maxLength","numeric","length","allowedTransactionKeys","chainId","data","gasLimit","gasPrice","nonce","to","computeAddress","key","publicKey","recoverAddress","digest","signature","serialize","transaction","raw","forEach","fieldInfo","options","hexPad","throwArgumentError","push","v","Math","floor","encode","sig","recoveryParam","pop","r","s","parse","rawTransaction","decode","tx","toNumber","error","console","log","isZero","slice","hash"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return Zero;\n    }\n    return BigNumber.from(value);\n}\nconst transactionFields = [\n    { name: \"nonce\", maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\", length: 20 },\n    { name: \"value\", maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n};\nexport function computeAddress(key) {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nexport function serialize(transaction, signature) {\n    checkProperties(transaction, allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n        let value = transaction[fieldInfo.name] || ([]);\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = arrayify(hexlify(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n            }\n        }\n        raw.push(hexlify(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof (chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    }\n    else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId));\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transation\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    }\n    else if (sig.v !== v) {\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n    return RLP.encode(raw);\n}\nexport function parse(rawTransaction) {\n    const transaction = RLP.decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n    }\n    catch (error) {\n        console.log(error);\n        return tx;\n    }\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    }\n    else {\n        // Signed Tranasaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        }\n        catch (error) {\n            console.log(error);\n        }\n        tx.hash = keccak256(rawTransaction);\n    }\n    return tx;\n}\n"]},"metadata":{},"sourceType":"module"}