{"ast":null,"code":"\"use strict\"; // We use this for base 36 maths\n\nimport { BN } from \"bn.js\";\nimport { arrayify, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address) {\n  if (!isHexString(address, 20)) {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n\n  address = address.toLowerCase();\n  const chars = address.substring(2).split(\"\");\n  const expanded = new Uint8Array(40);\n\n  for (let i = 0; i < 40; i++) {\n    expanded[i] = chars[i].charCodeAt(0);\n  }\n\n  const hashed = arrayify(keccak256(expanded));\n\n  for (let i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return \"0x\" + chars.join(\"\");\n} // Shims for environments that are missing some required constants and functions\n\n\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\nfunction log10(x) {\n  if (Math.log10) {\n    return Math.log10(x);\n  }\n\n  return Math.log(x) / Math.LN10;\n} // See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\n\n\nconst ibanLookup = {};\n\nfor (let i = 0; i < 10; i++) {\n  ibanLookup[String(i)] = String(i);\n}\n\nfor (let i = 0; i < 26; i++) {\n  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n} // How many decimal digits can we process? (for 64-bit float, this is 15)\n\n\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address) {\n  address = address.toUpperCase();\n  address = address.substring(4) + address.substring(0, 2) + \"00\";\n  let expanded = address.split(\"\").map(c => {\n    return ibanLookup[c];\n  }).join(\"\"); // Javascript can handle integers safely up to 15 (decimal) digits\n\n  while (expanded.length >= safeDigits) {\n    let block = expanded.substring(0, safeDigits);\n    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n  }\n\n  let checksum = String(98 - parseInt(expanded, 10) % 97);\n\n  while (checksum.length < 2) {\n    checksum = \"0\" + checksum;\n  }\n\n  return checksum;\n}\n\n;\nexport function getAddress(address) {\n  let result = null;\n\n  if (typeof address !== \"string\") {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    // Missing the 0x prefix\n    if (address.substring(0, 2) !== \"0x\") {\n      address = \"0x\" + address;\n    }\n\n    result = getChecksumAddress(address); // It is a checksummed address with a bad checksum\n\n    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n      logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n    } // Maybe ICAP? (we only support direct mode)\n\n  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    // It is an ICAP address with a bad checksum\n    if (address.substring(2, 4) !== ibanChecksum(address)) {\n      logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n    }\n\n    result = new BN(address.substring(4), 36).toString(16);\n\n    while (result.length < 40) {\n      result = \"0\" + result;\n    }\n\n    result = getChecksumAddress(\"0x\" + result);\n  } else {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n\n  return result;\n}\nexport function isAddress(address) {\n  try {\n    getAddress(address);\n    return true;\n  } catch (error) {}\n\n  return false;\n}\nexport function getIcapAddress(address) {\n  let base36 = new BN(getAddress(address).substring(2), 16).toString(36).toUpperCase();\n\n  while (base36.length < 30) {\n    base36 = \"0\" + base36;\n  }\n\n  return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n} // http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n\nexport function getContractAddress(transaction) {\n  let from = null;\n\n  try {\n    from = getAddress(transaction.from);\n  } catch (error) {\n    logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n  }\n\n  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n  return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));\n}\nexport function getCreate2Address(from, salt, initCodeHash) {\n  if (hexDataLength(salt) !== 32) {\n    logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n  }\n\n  if (hexDataLength(initCodeHash) !== 32) {\n    logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n  }\n\n  return getAddress(hexDataSlice(keccak256(concat([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}","map":{"version":3,"sources":["/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/lib.esm/index.js"],"names":["BN","arrayify","concat","hexDataLength","hexDataSlice","isHexString","stripZeros","BigNumber","keccak256","encode","Logger","version","logger","getChecksumAddress","address","throwArgumentError","toLowerCase","chars","substring","split","expanded","Uint8Array","i","charCodeAt","hashed","toUpperCase","join","MAX_SAFE_INTEGER","log10","x","Math","log","LN10","ibanLookup","String","fromCharCode","safeDigits","floor","ibanChecksum","map","c","length","block","parseInt","checksum","getAddress","result","match","toString","isAddress","error","getIcapAddress","base36","getContractAddress","transaction","from","nonce","toHexString","getCreate2Address","salt","initCodeHash"],"mappings":"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","sourcesContent":["\"use strict\";\n// We use this for base 36 maths\nimport { BN } from \"bn.js\";\nimport { arrayify, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction getChecksumAddress(address) {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = arrayify(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nexport function getAddress(address) {\n    let result = null;\n    if (typeof (address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (new BN(address.substring(4), 36)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nexport function isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexport function getIcapAddress(address) {\n    let base36 = (new BN(getAddress(address).substring(2), 16)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction) {\n    let from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));\n}\nexport function getCreate2Address(from, salt, initCodeHash) {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\n"]},"metadata":{},"sourceType":"module"}