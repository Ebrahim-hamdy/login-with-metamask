{"ast":null,"code":"import _regeneratorRuntime from\"/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import'./Login.css';import React from'react';import Web3 from'web3';let web3=undefined;// Will hold the web3 instance\nexport class Login extends React.Component{constructor(...args){var _this;super(...args);_this=this;this.state={loading:false// Loading button state\n};this.handleAuthenticate=({publicAddress,signature})=>fetch(\"\".concat(process.env.REACT_APP_BACKEND_URL,\"/auth\"),{body:JSON.stringify({publicAddress,signature}),headers:{'Content-Type':'application/json'},method:'POST'}).then(response=>response.json());this.handleClick=/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var onLoggedIn,coinbase,publicAddress;return _regeneratorRuntime.wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:onLoggedIn=_this.props.onLoggedIn;// Check if MetaMask is installed\nif(window.ethereum){_context.next=4;break;}window.alert('Please install MetaMask first.');return _context.abrupt(\"return\");case 4:if(web3){_context.next=15;break;}_context.prev=5;_context.next=8;return window.ethereum.enable();case 8:// We don't know window.web3 version, so we use our own instance of Web3\n// with the injected provider given by MetaMask\nweb3=new Web3(window.ethereum);_context.next=15;break;case 11:_context.prev=11;_context.t0=_context[\"catch\"](5);window.alert('You need to allow MetaMask.');return _context.abrupt(\"return\");case 15:_context.next=17;return web3.eth.getCoinbase();case 17:coinbase=_context.sent;if(coinbase){_context.next=21;break;}window.alert('Please activate MetaMask first.');return _context.abrupt(\"return\");case 21:publicAddress=coinbase.toLowerCase();_this.setState({loading:true});// Look if user with current publicAddress is already present on backend\nfetch(\"\".concat(process.env.REACT_APP_BACKEND_URL,\"/users?publicAddress=\").concat(publicAddress)).then(response=>response.json())// If yes, retrieve it. If no, create it.\n.then(users=>users.length?users[0]:_this.handleSignup(publicAddress))// Popup MetaMask confirmation modal to sign message\n.then(_this.handleSignMessage)// Send signature to backend on the /auth route\n.then(_this.handleAuthenticate)// Pass accessToken back to parent component (to save it in localStorage)\n.then(onLoggedIn).catch(err=>{window.alert(err);_this.setState({loading:false});});case 24:case\"end\":return _context.stop();}},_callee,null,[[5,11]]);}));this.handleSignMessage=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2({publicAddress,nonce}){var signature;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:_context2.prev=0;_context2.next=3;return web3.eth.personal.sign(\"I am signing my one-time nonce: \".concat(nonce),publicAddress,''// MetaMask will ignore the password argument here\n);case 3:signature=_context2.sent;return _context2.abrupt(\"return\",{publicAddress,signature});case 7:_context2.prev=7;_context2.t0=_context2[\"catch\"](0);throw new Error('You need to sign the message to be able to log in.');case 10:case\"end\":return _context2.stop();}},_callee2,null,[[0,7]]);}));return function(_x){return _ref2.apply(this,arguments);};}();this.handleSignup=publicAddress=>{return fetch(\"\".concat(process.env.REACT_APP_BACKEND_URL,\"/users\"),{body:JSON.stringify({publicAddress}),headers:{'Content-Type':'application/json'},method:'POST'}).then(response=>response.json());};}render(){const loading=this.state.loading;return/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"button\",{className:\"Login-button Login-mm\",onClick:this.handleClick},loading?'Loading...':'Login with MetaMask'));}}","map":{"version":3,"sources":["/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/packages/frontend/src/Login/Login.tsx"],"names":["React","Web3","web3","undefined","Login","Component","state","loading","handleAuthenticate","publicAddress","signature","fetch","process","env","REACT_APP_BACKEND_URL","body","JSON","stringify","headers","method","then","response","json","handleClick","onLoggedIn","props","window","ethereum","alert","enable","eth","getCoinbase","coinbase","toLowerCase","setState","users","length","handleSignup","handleSignMessage","catch","err","nonce","personal","sign","Error","render"],"mappings":"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","sourcesContent":["import './Login.css';\n\nimport React from 'react';\nimport Web3 from 'web3';\n\nimport { Auth } from '../types';\n\ninterface Props {\n  onLoggedIn: (auth: Auth) => void;\n}\n\nlet web3: Web3 | undefined = undefined; // Will hold the web3 instance\n\nexport class Login extends React.Component<Props> {\n  state = {\n    loading: false, // Loading button state\n  };\n\n  handleAuthenticate = ({\n    publicAddress,\n    signature,\n  }: {\n    publicAddress: string;\n    signature: string;\n  }) =>\n    fetch(`${process.env.REACT_APP_BACKEND_URL}/auth`, {\n      body: JSON.stringify({ publicAddress, signature }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    }).then((response) => response.json());\n\n  handleClick = async () => {\n    const { onLoggedIn } = this.props;\n\n    // Check if MetaMask is installed\n    if (!(window as any).ethereum) {\n      window.alert('Please install MetaMask first.');\n      return;\n    }\n\n    if (!web3) {\n      try {\n        // Request account access if needed\n        await (window as any).ethereum.enable();\n\n        // We don't know window.web3 version, so we use our own instance of Web3\n        // with the injected provider given by MetaMask\n        web3 = new Web3((window as any).ethereum);\n      } catch (error) {\n        window.alert('You need to allow MetaMask.');\n        return;\n      }\n    }\n\n    const coinbase = await web3.eth.getCoinbase();\n    if (!coinbase) {\n      window.alert('Please activate MetaMask first.');\n      return;\n    }\n\n    const publicAddress = coinbase.toLowerCase();\n    this.setState({ loading: true });\n\n    // Look if user with current publicAddress is already present on backend\n    fetch(\n      `${process.env.REACT_APP_BACKEND_URL}/users?publicAddress=${publicAddress}`\n    )\n      .then((response) => response.json())\n      // If yes, retrieve it. If no, create it.\n      .then((users) =>\n        users.length ? users[0] : this.handleSignup(publicAddress)\n      )\n      // Popup MetaMask confirmation modal to sign message\n      .then(this.handleSignMessage)\n      // Send signature to backend on the /auth route\n      .then(this.handleAuthenticate)\n      // Pass accessToken back to parent component (to save it in localStorage)\n      .then(onLoggedIn)\n      .catch((err) => {\n        window.alert(err);\n        this.setState({ loading: false });\n      });\n  };\n\n  handleSignMessage = async ({\n    publicAddress,\n    nonce,\n  }: {\n    publicAddress: string;\n    nonce: string;\n  }) => {\n    try {\n      const signature = await web3!.eth.personal.sign(\n        `I am signing my one-time nonce: ${nonce}`,\n        publicAddress,\n        '' // MetaMask will ignore the password argument here\n      );\n\n      return { publicAddress, signature };\n    } catch (err) {\n      throw new Error('You need to sign the message to be able to log in.');\n    }\n  };\n\n  handleSignup = (publicAddress: string) => {\n    return fetch(`${process.env.REACT_APP_BACKEND_URL}/users`, {\n      body: JSON.stringify({ publicAddress }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    }).then((response) => response.json());\n  };\n\n  render() {\n    const { loading } = this.state;\n    return (\n      <div>\n        <button className=\"Login-button Login-mm\" onClick={this.handleClick}>\n          {loading ? 'Loading...' : 'Login with MetaMask'}\n        </button>\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}