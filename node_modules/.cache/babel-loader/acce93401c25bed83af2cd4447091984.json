{"ast":null,"code":"\"use strict\";\n\nimport _regeneratorRuntime from \"/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n} // Crawl up the constructor chain to find a static method\n\nexport function getStatic(ctor, key) {\n  for (let i = 0; i < 32; i++) {\n    if (ctor[key]) {\n      return ctor[key];\n    }\n\n    if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n      break;\n    }\n\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n\n  return null;\n}\nexport function resolveProperties(object) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var promises, results;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          promises = Object.keys(object).map(key => {\n            const value = object[key];\n            return Promise.resolve(value).then(v => ({\n              key: key,\n              value: v\n            }));\n          });\n          _context.next = 3;\n          return Promise.all(promises);\n\n        case 3:\n          results = _context.sent;\n          return _context.abrupt(\"return\", results.reduce((accum, result) => {\n            accum[result.key] = result.value;\n            return accum;\n          }, {}));\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n}\nexport function checkProperties(object, properties) {\n  if (!object || typeof object !== \"object\") {\n    logger.throwArgumentError(\"invalid object\", \"object\", object);\n  }\n\n  Object.keys(object).forEach(key => {\n    if (!properties[key]) {\n      logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n    }\n  });\n}\nexport function shallowCopy(object) {\n  const result = {};\n\n  for (const key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n}\nconst opaque = {\n  bigint: true,\n  boolean: true,\n  \"function\": true,\n  number: true,\n  string: true\n};\n\nfunction _isFrozen(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return true;\n  }\n\n  if (Array.isArray(object) || typeof object === \"object\") {\n    if (!Object.isFrozen(object)) {\n      return false;\n    }\n\n    const keys = Object.keys(object);\n\n    for (let i = 0; i < keys.length; i++) {\n      if (!_isFrozen(object[keys[i]])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return logger.throwArgumentError(\"Cannot deepCopy \".concat(typeof object), \"object\", object);\n} // Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\n\n\nfunction _deepCopy(object) {\n  if (_isFrozen(object)) {\n    return object;\n  } // Arrays are mutable, so we need to create a copy\n\n\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(item => deepCopy(item)));\n  }\n\n  if (typeof object === \"object\") {\n    const result = {};\n\n    for (const key in object) {\n      const value = object[key];\n\n      if (value === undefined) {\n        continue;\n      }\n\n      defineReadOnly(result, key, deepCopy(value));\n    }\n\n    return result;\n  }\n\n  return logger.throwArgumentError(\"Cannot deepCopy \".concat(typeof object), \"object\", object);\n}\n\nexport function deepCopy(object) {\n  return _deepCopy(object);\n}\nexport class Description {\n  constructor(info) {\n    for (const key in info) {\n      this[key] = deepCopy(info[key]);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/lib.esm/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Logger","version","logger","defineReadOnly","object","name","Object","defineProperty","enumerable","writable","getStatic","ctor","key","i","prototype","getPrototypeOf","constructor","resolveProperties","promises","keys","map","v","all","results","reduce","accum","checkProperties","properties","throwArgumentError","forEach","shallowCopy","opaque","bigint","boolean","number","string","_isFrozen","undefined","Array","isArray","isFrozen","length","_deepCopy","freeze","item","deepCopy","Description","info"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nexport function resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nexport function checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nexport function shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            if (!_isFrozen(object[keys[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nexport function deepCopy(object) {\n    return _deepCopy(object);\n}\nexport class Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}