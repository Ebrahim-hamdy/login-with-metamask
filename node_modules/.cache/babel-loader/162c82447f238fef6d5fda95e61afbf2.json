{"ast":null,"code":"\"use strict\";\n\nimport { HashZero } from \"@ethersproject/constants\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8\";\nexport function formatBytes32String(text) {\n  // Get the bytes\n  const bytes = toUtf8Bytes(text); // Check we have room for null-termination\n\n  if (bytes.length > 31) {\n    throw new Error(\"bytes32 string must be less than 32 bytes\");\n  } // Zero-pad (implicitly null-terminates)\n\n\n  return hexlify(concat([bytes, HashZero]).slice(0, 32));\n}\nexport function parseBytes32String(bytes) {\n  const data = arrayify(bytes); // Must be 32 bytes with a null-termination\n\n  if (data.length !== 32) {\n    throw new Error(\"invalid bytes32 - not 32 bytes long\");\n  }\n\n  if (data[31] !== 0) {\n    throw new Error(\"invalid bytes32 string - no null terminator\");\n  } // Find the null termination\n\n\n  let length = 31;\n\n  while (data[length - 1] === 0) {\n    length--;\n  } // Determine the string value\n\n\n  return toUtf8String(data.slice(0, length));\n}","map":{"version":3,"sources":["/Users/ebra/code/blockchain/tezos/login-with-metamask-demo/node_modules/@ethersproject/strings/lib.esm/bytes32.js"],"names":["HashZero","arrayify","concat","hexlify","toUtf8Bytes","toUtf8String","formatBytes32String","text","bytes","length","Error","slice","parseBytes32String","data"],"mappings":"AAAA;;AACA,SAASA,QAAT,QAAyB,0BAAzB;AACA,SAASC,QAAT,EAAmBC,MAAnB,EAA2BC,OAA3B,QAA0C,sBAA1C;AACA,SAASC,WAAT,EAAsBC,YAAtB,QAA0C,QAA1C;AACA,OAAO,SAASC,mBAAT,CAA6BC,IAA7B,EAAmC;AACtC;AACA,QAAMC,KAAK,GAAGJ,WAAW,CAACG,IAAD,CAAzB,CAFsC,CAGtC;;AACA,MAAIC,KAAK,CAACC,MAAN,GAAe,EAAnB,EAAuB;AACnB,UAAM,IAAIC,KAAJ,CAAU,2CAAV,CAAN;AACH,GANqC,CAOtC;;;AACA,SAAOP,OAAO,CAACD,MAAM,CAAC,CAACM,KAAD,EAAQR,QAAR,CAAD,CAAN,CAA0BW,KAA1B,CAAgC,CAAhC,EAAmC,EAAnC,CAAD,CAAd;AACH;AACD,OAAO,SAASC,kBAAT,CAA4BJ,KAA5B,EAAmC;AACtC,QAAMK,IAAI,GAAGZ,QAAQ,CAACO,KAAD,CAArB,CADsC,CAEtC;;AACA,MAAIK,IAAI,CAACJ,MAAL,KAAgB,EAApB,EAAwB;AACpB,UAAM,IAAIC,KAAJ,CAAU,qCAAV,CAAN;AACH;;AACD,MAAIG,IAAI,CAAC,EAAD,CAAJ,KAAa,CAAjB,EAAoB;AAChB,UAAM,IAAIH,KAAJ,CAAU,6CAAV,CAAN;AACH,GARqC,CAStC;;;AACA,MAAID,MAAM,GAAG,EAAb;;AACA,SAAOI,IAAI,CAACJ,MAAM,GAAG,CAAV,CAAJ,KAAqB,CAA5B,EAA+B;AAC3BA,IAAAA,MAAM;AACT,GAbqC,CActC;;;AACA,SAAOJ,YAAY,CAACQ,IAAI,CAACF,KAAL,CAAW,CAAX,EAAcF,MAAd,CAAD,CAAnB;AACH","sourcesContent":["\"use strict\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8\";\nexport function formatBytes32String(text) {\n    // Get the bytes\n    const bytes = toUtf8Bytes(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error(\"bytes32 string must be less than 32 bytes\");\n    }\n    // Zero-pad (implicitly null-terminates)\n    return hexlify(concat([bytes, HashZero]).slice(0, 32));\n}\nexport function parseBytes32String(bytes) {\n    const data = arrayify(bytes);\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error(\"invalid bytes32 - not 32 bytes long\");\n    }\n    if (data[31] !== 0) {\n        throw new Error(\"invalid bytes32 string - no null terminator\");\n    }\n    // Find the null termination\n    let length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return toUtf8String(data.slice(0, length));\n}\n"]},"metadata":{},"sourceType":"module"}